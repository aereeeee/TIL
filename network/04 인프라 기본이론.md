# 04 인프라를 지탱하는 기본 이론
## 4.1 웹데이터 흐름
### 직렬/병렬
* 미시적 관점의 병렬 - PC 하나에 여러개 CPU 탑재
* 거시적 관점의 병렬 - 대규모 웹서비스에서 방대한 사용자 요청 처리하기 위해 수많은 서버를 배치하여 병렬로 처리함
* 병렬화한 하드웨어를 놀리지 않고 효율적으로 활용하는 것이 중요
### 병목 구간(bottleneck)
* 전체 흐름을 느리게 만드는 구간 ex) 3차선 <-> 1차선 합류점, 분기점 
* 분담할 수 있는 처리 - CPU 코어를 늘려 병렬 처리한다.
* 분담할 수 없는 처리 - CPU 클럭 주파수를 올려 고속처리한다.
* 병목현상 최소화 하기 위해 병렬 처리 시 가능한 병렬화, 직렬 처리 필요한 경우 효율성 높이는 것이 중요
### 사용 예시 - 웹서버, AP서버
* 웹서버에서 복수의 프로세스가 사용자 요청 분담하여 병렬처리
* AP서버에서 한 프로세스 내부의 복수의 스레드가 병렬 처리
* 멀티 프로세스와 멀티 스레드를 모두 이용하는 하이브리드형도 있음
* CPU 코어가 1개라면 한 프로세스 혹은 한 스레드만 한번에 실행가능하므로 고려 필요 
### 사용 예시 - DB서버
* 오라클의 경우 클라이언트 접속 수만큼 DB서버 프로세스 생성
* 공유서버형(하이브리드형)은 멀티 프로세스와 멀티 스레드 모두 사용
* DBWR 프로세스의 수를 늘려 병렬화 하기도 함
    * DBWR - 데이터 파일 생성 시 병목 현상 발생하는 경우 메모리에 캐시된 갱신 완료 데이터를 HDD에 기록하는 프로세스
* 비동기 I/O 사용하여 OS측에서의 쓰기 처리 병렬화
### 장/단 비교
* **직렬** : 구조가 간단해서 설계, 구현 난이도가 낮지만 복수의 리소스를 유용하게 이용할 수 없다.
* **병렬** : 복수 리소스 유용하게 이용, 동일 시간당 처리량 증가, 일부 고장나더라도 처리 계속 할 수 있음(이중화). 그러나 오버헤드가 발생하고 배타제어 등을 고려해야 하며 설계, 구현 난이도가 높다.
    * 배타 제어 : 복수 처리가 공유 자원에 동시 접근 시 일관성 위해 **배타적 제어(mutual exclusion)**로 보호한다.
### 병렬 처리 시 주의 사항
* 병렬화를 통해 속도는 빨라지지 않지만, 단위 시간당 처리량 늘릴 수 있다.
    * 병렬 처리에서는 합츄점, 직렬화 구간, 분기점이 병목 지점이 되기 쉽다.
    * 병렬 처리 후 분담한 일을 다시 집약할 때 오버헤드 발생. 따라서 오버헤드를 감안하여 병렬화가 유효한 부분을 파악해서 진행해야한다.
-------------------------------------------------------------------------------------

## 4.2 동기 / 비동기
* 동기 : 일을 부탁한 후 끝날 때까지 기다림. 끝났는지 여부를 확실하게 확인 가능
* 비동기 : 일을 부탁한 후 기다리지 않고 병렬로 다른 일을 수행. 끝났는지 여부를 확인하기 위해 별도의 방법 필요
### 사용 예시
* Ajax : 웹페이지에서 비동기 통신을 통해 화면의 일부분만 갱신하는 기술
* DBMS의 비동기 I/O : DBMS 프로세스가 OS 커널에 I/O 요구한 후 처리가 끝나기 기다리지 않고 다음 I/O를 발행함. 각각의 I/O 처리가 끝나면 완료 여부 확인(OS라이브러리나 시스템콜을 사용함) 
### 장/단 비교
* **동기** 
    * 장: 처리 완료 여부 쉽게 확인. 구조가 간단해서 설계, 구현 난이도가 낮다.
    * 단: 처리가 끝날 때까지 대기 시간을 활용할 수 없다.
* **비동기** 
    * 장: 처리가 진행되는 동안 시간을 효율적으로 사용할 수 있다.
    * 단: 불필요한 확인 처리가 늘어난다. 구조가 복잡해 구현 난이도가 높다.
### 비동기 처리 시 주의 사항
* 처리가 끝나지 않은 상태에서 다음 처리 진행해도 문제 없는지 고려
* 처리가 끝났는지 확인할 필요가 있는지 고려
-------------------------------------------------------------------------------------

## 4.3 큐
* 대기 행렬, 줄을 설 때는 마지막에, 처리는 선두부터 순서대로. 
* 선입선출(FIFO)
### 사용 예시
* CPU 처리를 기다리고 있는 프로세스나 스레드 행렬
    * 런큐(run-queue)라고 함 (런큐 값/ CPU 코어 수 = 1 이면 일반적으로 적합한 상태)
* HDD 등의 저장소 읽기 처리를 기다리는 I/O 행렬
* 네트워크 접속 성립을 기다리는 접속 요구 행렬
### 사용 예시 - 데이터베이스 디스크 I/O
* LGWR(log writer) 프로세스와 같이 고속 I/O가 요구되는 프로세스는 전용 디스크에 어세스하게 함.
* 공유 메모리의 캐시에 I/O 요청 보관하여 성능 고속화
### 정리
* 데이터 베이스 - 데이터베이스큐, OS런큐, I/O 요청큐 등 확인하여 처리 지연 체크
* CPU, 메모리 - CPU 사용률 + 런큐 길이 체크
* 메시지 큐 - 어플리케이션 간 상호 운용성 향상
    * 메세지 큐 : 프로세스가 사용자가 취한 행동을 사건으로 해석하여 사건에 대응하는 처리를 수행할 수 있게 한다.
-------------------------------------------------------------------------------------
## 4.4 배타적 제어
* 복수의 처리가 공유 자원에 동시에 엑세스하면 불일치가 발생할 수 잇으므로 배타적 제어로 보호한다.
* 배타적 제어에서는 특정 처리가 공유 자원을 이용하는 동안 다른 처리가 이용하지 못하게 한다.
* 배타적 제어가 이루어지는 구간은 병목 현상이 발생하기 쉽다.
### 사용 예시
* DBMS - 공유 데이터를 동시에 변경하지 못하도록 배타적 제어 
    * 스핀락: 매우 짧은 시간동안 락을 유지할 때 CPU에서 의미 없는 처리를 반복 하며 대기하는 방식. =래치(latch)
    * 슬립락: 비교적 장시간 락을 유지하도록 큐를 이용하여 관리.
    * 어댑티브락: 상황에 따라 스핀, 슬립을 판단하는 방식.
* OS커널
    * 빅 커널락(BKL): 리눅스 커널을 유지하는 하나의 스핀락
* 클러스터 데이터베이스 - 여러 대의 DB서버를 조합해서 하나의 데이터베이스로 사용하는 액티브-액티브 클러스터 DB
    * 각 서버에서 병렬 처리를 해도 서버 간 배타적 제어에 의해 직렬화 될 수 있음. 서버 간 데이터 교환과 배타적 제어에 의한 대기 상태 줄이는 것이 중요
* 멀티 프로세스(멀티 코어) 시스템 - 하드웨어를 이용한 배타적 제어 구현.
    * CPU에 배타적 제어 위한 `test and set` 명령어 존재.
    * CPU 코어 간 협력 체제
-------------------------------------------------------------------------------------
## 4.5 상태 저장/비저장
* 상태 저장
    * 상태를 고려하므로 복잡한 처리가가능하지만 시스템 복잡성이 커진다.
    * 부여된 정보에 따라 상태가 전이 된다. 그림으로 표현한 것 - 상태 전이도
* 상태 비저장
    * 상태를 고려하지 않기 때문에 간단하고 성능이나 안정성 측면에서 우수하다.
    * 복잡한 처리가 어렵다.
### 사용 예시 
* 프로세스 상태 전이
    * 실행 가능 상태 - 실행 상태 - 대기 상태 / 처리 끝나면 종료 상태
* http - 상태비저장 프로토콜, 브라우저가 HTTP 서버에 접속할 때 사용, 세션 사용하여 상태저장 구현
* ssh - 상태저장 프로토콜
### 장/단 비교
* **상태저장** 
    * 장: 자신의 상태를 이해하므로 요충 내용 최소화
    * 단: 서버 측 처리가 복잡해져 리소스 부하가 높아지고 대량 요청이 버거워질 수 있다.
* **상태 비저장** 
    * 장: 요청과 응답 구조가 간단함
    * 단: 매번 신규 요청이 생성된다.

-------------------------------------------------------------------------------------
## 4.6 가변 길이/고정 길이
* 가변 길이 - 데이터를 저장할 공간의 크기가 정해져 있지 않은 경우 
    * 공간을 유용하게 활용할 수 있지만 성능 면에서 불안정하다.
    * 원하는 데이터를 찾을때 복잡함.
    * 데이터가 특정 공간에 편중되기 쉬움 
* 고정 길이 - 데이터를 저장할 공간의 크기가 정해져 있는 경우.
    * 남는 공간이 생기지만 성능 면에서 안정적이다.
    * 원하는 데이터 위치에 쉽게 엑세스
### 사용 예시
* 파일 시스템
    * 윈도우즈 NTFS 시스템 - 고정길이 
* 네트워크 데이터 교환 - 가변길이 패킷으로 데이터 처리
    * 일반적인 이더넷 MTU(패킷 최대 크기)가 1500바이트
    * TCP/IP헤더 40 바이트
    * MSS(세그먼트 데이터 최대 크기)는 1460바이트 : 데이터를 1460 바이트의 세그먼트로 분할하여 전송

-------------------------------------------------------------------------------------
## 4.7 데이터 구조(베열, 연결 리스트)
* 배열은 데이터를 빈틈없이 순서대로 나영한 구조로 탐색이 빠르지만 데이터 추가 삭제 시 느림
* 연결 리스트는 데이터를 선으로 연결한 구조로 탐색은 느리지만 데이터 추가 삭제시 빠름
### 사용 예시
* 해시 테이블 - 배열이 색인 형태로 나열 되고 각각 인덱스에 연결 리스트의 최초 데이터 위치를 담음.
    * DB의 SQL 정보 캐시 - SQL실행 시 메모리에 캐시 - 똑같은 SQL 실행 시 재사용
        * SQL을 고정길이 해시 값으로 변환하여 해시 값 배열로 부터 연결 리스트를 찾아가 빠르게 SQL탐색
    * OS 커널의 데이터 캐시에 해시 테이블 사용 
    * KVS(key value store) 형태로 사용
-------------------------------------------------------------------------------------
## 4.8 탐색 알고리즘(해시, 트리)
* 데이터를 빠르게 찾기 위해 데이터를 정리해야 한다.
* 데이터 탐색 시 데이터 구조와 저장방식(메모리, HDD, SDD 등) 특성에 따라 적합한 데이터 정리 방법 달라진다.
* 데이터 정리방법 = 데이터 구조 / 처리 순서 = 알고리즘
* 처리 상대에 맞추어 데이터 구조를 정리해야 하므로 알고리즘과 데이터 구조는 함께 다루어진다.
### 사용 예시
* DBMS  
    * 풀 스캔 - 데이터 탐색 시 디스크에서 테이블 데이터를 모두 읽어 조사함 
    * B 트리 인덱스 - root를 기준으로 왼쪽과 오른쪽에 발란스를 맞춰서 leaf block의 값을 찾아가는 방식
        * 루트 블록 - 브랜치 블록 - 리프 블록 - 원하는 데이터 블록 
        * 위의 경우 4개의 블록만 읽으면 됨
        * 트리 구조 계층이 깊어지지 않도록 디스크 I/O를 최소한으로 제어
    * T 트리 인덱스 - 인메모리 DB에서 사용
        * 이진 트리로 계층은 깊어지지만 키 값 비교 횟수가 적어 메모리 데이터 탐색에 적합
    * 해시 테이블 
        * 키는 해시 함수를 통해 해시값으로 변환
        * 고정길이 데이터이므로 구조가 간단. 검색이 빠름
        * 등호 검색에서 강함 / 범위 검색에는 약함

### 주의 사항
* 테이블 데이터를 모두 읽을 경우 인덱스 사용하면 오히려 오버헤드 발생
    * 인덱스 블록을 읽는 추가 디스크 I/O / 인덱스 블록을 통해 엑세스해야 하는 블록수 가 늘어나므로 추가 I/O 발생
* DBMS에서 인덱스 만들면 검색은 빠르지만 갱신 시 오버헤드 발생 고려
-------------------------------------------------------------------------------------
