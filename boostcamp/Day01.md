# Day01 study

## 자바스크립트
화살표 함수    
- () => {} 매개변수가 한개인 경우만 소괄호를 생략할 수 있다.
- 몸체가 한줄의 return문일 경우 중괄호를 생략할 수 있다. * 객체소환시는 중괄호 필요
- 화살표 함수는 이름이 있는 익명함수로만 사용할 수 있다.
- 일반 함수와 가장 큰 차이점은 **this** 

> 일반적으로 자바스크립트는 함수를 **호출**할 떄의 방식에 따라 this가 바인딩 될 객체가 동적으로 결정된다.  

> 화살표 함수는 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정된다. 화살표 함수의 this 언제나 상위 스코프의 this를 가리킨다. 이를 Lexical this라고 한다.  

> 리액트에서 콜백함수 내부에 this.setState를 선언할 시 undefined 오류가 나기 쉬운데 그 이유:  
> 콜백함수 내에서 사용된 this는 전역 객체에 바인딩된다. 그런데 babel로 컴파일되는 코드는 strict mode로 실행이 되는데, strict mode에서는 this가 전역 객체(window)에 바인딩되는 상황을 잘못된 코드라 판단하고 undefined에 바인딩시킨다.   
>이때 화살표 함수로 정의하면 this를 해당 함수가 선언된 부모의 렉시컬 스코프로부터 계승받기때문에 오류를 해결 할 수 있다.
  
삼항연산자
```javascript
return arr[0]%arr[1]==0 ? arr[1] : gcd([arr[1], arr[0]%arr[1]]);
```

짧은 조건문
```javascript
 //1. <조건문> || <조건문이 거짓일 때 실행될 코드>
    true || alert('실행A');
    false || alert('실행B');
        
//2. <조건문> && <조건문이 참일 때 실행될 코드>
    true && alert('실행A');
    false && alert('실행B');
```

## 알고리즘
최대공약수 gcd(arr)에서 숫자를 sorting하지 않아도 되는 이유   
- 작은수를 큰수로 나누면 %의 값이 작은수 그대로 출력. -> 재귀함수로 작은값이 다시 두번쨰 요소로 들어가게 되므로 자연스럽게 sorting됨

n개 수의 최대공약수  
- 2개씩 처리해 나가기 : reduce()로 개선 가능

계산 완료한 배열의 elem을 지우는 여러가지 방법
- pop()
- shift()
- splice()


## 피어 컴파일링 체크포인트
```
1. [O] 두 수의 최대공약수를 계산하는 함수를 구현
2. [O] n개의 수를 입력받아 최대공약수를 계산하는 multipleGcd함수 구현
3. [O] 본인의 브랜치로 PR을 보냄
4. [O] 함수의 실행결과가 VSCODE콘솔에 출력
5. [O] 커밋로그가 함수단위로 되어 있음
```

## 스스로 확인할 사항
- 최대공약수 문제는 잘 동작하는가? O
- 필요한 함수를 여러가 만들었는가? O
- git의 branch에 대해서 이해를 하고 있는가? 

```
커밋하면 Git은 현 Staging Area에 있는 데이터의 스냅샷에 대한 포인터, 저자나 커밋 메시지 같은 메타데이터, 이전 커밋에 대한 포인터 등을 포함하는 커밋 개체(커밋 Object)를 저장한다. 
이전 커밋 포인터가 있어서 현재 커밋이 무엇을 기준으로 바뀌었는지를 알 수 있다. 
최초 커밋을 제외한 나머지 커밋은 이전 커밋 포인터가 적어도 하나씩 있고 
브랜치를 합친 Merge 커밋 같은 경우에는 이전 커밋 포인터가 여러 개 있다.

git commit 으로 커밋하면 먼저 루트 디렉토리와 각 하위 디렉토리의 트리 개체를 체크섬과 함께 저장소에 저장한다. 
그다음에 커밋 개체를 만들고 메타데이터와 루트 디렉토리 트리 개체를 가리키는 포인터 정보를 커밋 개체에 넣어 저장한다. 
```
![이미지1](https://git-scm.com/book/en/v2/images/commit-and-tree.png)
```
다시 파일 수정하고 커밋하면 이전 커밋 가리킨다
```
![이미지2](https://git-scm.com/book/en/v2/images/commits-and-parents.png)
```
testing이라는 브랜치를 만든다. 새 브랜치도 지금 작업중인 마지막 커밋을 가리킨다.
```
![이미지3](https://git-scm.com/book/en/v2/images/two-branches.png)
```
다른 버전 관리 시스템과는 달리 Git은 'HEAD’라는 특수한 포인터가 있다. 이 포인터는 지금 작업하는 로컬 브랜치를 가리킨다. 브랜치를 새로 만들었지만, Git은 아직 master 브랜치를 가리키고 있다. git branch 명령은 브랜치를 만들기만 하고 브랜치를 옮기지 않는다.
git checkout 명령으로 다른 브랜치로 이동할 수 있다. 한번 testing 브랜치로 바꿔보자.
이제 HEAD는 testing브랜치를 가리킨다.
이상태에서 테스팅 브랜치를 커밋하면, HEAD가 가리키는 testing 브랜치가 새 커밋을 가리킴
```
![이미지4](https://git-scm.com/book/en/v2/images/advance-testing.png)
```
프로젝트 히스토리는 이제 분리돼 진행한다(갈라지는 브랜치). 우리는 브랜치를 하나 만들어 그 브랜치에서 일을 좀 하고, 다시 원래 브랜치로 되돌아와서 다른 일을 했다. 두 작업 내용은 서로 독립적으로 각 브랜치에 존재한다. 커밋 사이를 자유롭게 이동하다가 때가 되면 두 브랜치를 Merge 한다. 간단히 branch, checkout, commit 명령을 써서 말이다.
git log 명령으로 쉽게 확인할 수 있다. 현재 브랜치가 가리키고 있는 히스토리가 무엇이고 어떻게 갈라져 나왔는지 보여준다. git log --oneline --decorate --graph --all 이라고 실행하면 히스토리를 출력한다.
```
![이미지5](https://git-scm.com/book/en/v2/images/advance-master.png)
```
실제로 Git의 브랜치는 어떤 한 커밋을 가리키는 40글자의 SHA-1 체크섬 파일에 불과하기 때문에 만들기도 쉽고 지우기도 쉽다. 새로 브랜치를 하나 만드는 것은 41바이트 크기의 파일을(40자와 줄 바꿈 문자) 하나 만드는 것에 불과하다.
게다가 커밋을 할 때마다 이전 커밋의 정보를 저장하기 때문에 Merge 할 때 어디서부터(Merge Base) 합쳐야 하는지 안다.
```

- vscode에서 개발한 후에 commit을 하고, fork한 저장소로 잘 push했는가? O


## 다같이 확인할 사항
- fork에서 시작해서 PR을 보낼때까지의 흐름에 대해서 제대로 이해하고 있는지 서로 설명해본다.

```
1. fork하여 나의 저장소로 프로젝트를 가져온다.
2. 해당 프로젝트를 clone하여 로컬에 가져온다. 이때 single-branch 옵션을 주어 특정 브랜치만 가져오도록 한다.
3. Staged 상태로 만들려면 git add 명령을 실행해야 한다. git add는 파일을 새로 추적할 때도 사용하고 수정한 파일을 Staged 상태로 만들 때도 사용한다. 
( commit 명령을 실행하는 시점의 버전이 커밋되는 것이 아니라 마지막으로 git add 명령을 실행했을 때의 버전이 커밋된다. 그러니까 git add 명령을 실행한 후에 또 파일을 수정하면 git add 명령을 다시 실행해서 최신 버전을 Staged 상태로 만들어야 한다 ) 
4. feature를 완성하면 커밋한다.
5. 자신의 저장소에 push한다.
6. 원래 저장소의 자신의 브랜치에 pull request를 생성한다.
```

- git add와 commit을 할때 git 내부에서는 어떤 일이 일어나는 것인지 찾아서 학습하고 이를 정리한다.
```
저장소 (저장공간; 레포지토리; repository)
작업공간을 Git이 제공하는 자료구조 안에 압축시켜 넣은 것이다. 저장소는 로컬 저장소와 원격 저장소로 나뉜다. 일반적으로 저장소라고 하면 로컬 저장소를 말한다. git init 명령어로 해당 작업공간의 저장소를 생성하면 작업공간 하위에 .git이라는 이름의 폴더가 생기고 이 저장소 안에 모든 커밋들이 들어있다.

원격 (원격 저장소; 리모트 저장소; remote repository)
저장소가 내 PC의 프로젝트 폴더 안이 아닌 다른 어딘가의 서버에 위치해 있으면 원격 저장소라고 한다. 원격 저장소를 사용하면 여러 사람이 서버에 있는 하나의 저장소를 공유해서 공동으로 작업할 수 있다.

커밋(commit; 변경사항; 이력; snapshot; 스냅샷)
(명사) 어떤 순간 작업공간의 상태를 저장한 것. 작업공간 안에 있는 모든 파일과 파일의 데이터를 사진 찍듯이 복사해서 저장소에 보존한다. 즉 커밋은 작업공간의 어떤 시점의 스냅샷이다.
(동사) '커밋한다'는 말은 커밋을 추가한다는 뜻이다. 즉 현재 작업공간의 상태를 커밋으로 만들어서 저장소에 저장한다는 의미이다.

워킹 디렉토리의 모든 파일은 크게 Tracked와 Untracked로 나눈다. 
Tracked 파일은 Unmodified와 Modified 그리고 Staged(커밋하면 저장소에 기록되는) 상태 중 하나이다.
1. git add 
: untracked인 파일에 대해서는 tracked가 이루어지고 동시에 staged상태가 된다.
2. git commit 
: 커밋하면, 그 시점 저장소의 “스냅샷”을 찍어, 프로젝트를 이전의 어떠한 상태로든 재평가하거나 복원할 수 있는 체크포인트를 가질 수 있다.
```

- 여러명이 협업을 하며 프로젝트를 개발할때는 다양한 branch전략을 세워서 한다. 실무에서 사용하는 git workflow에 대해서 찾아보고, 왜 그런 전략이 필요한지 고민한 후 정리한다.

![이미지](https://backlog.com/app/themes/backlog-child/assets/img/guides/git/collaboration/branching_workflows_001.png)
```
Git-flow에는 5가지 종류의 브랜치가 존재합니다. 항상 유지되는 메인 브랜치들(master, develop)과 일정 기간 동안만 유지되는 보조 브랜치들(feature, release, hotfix)이 있습니다. 

master : 제품으로 출시될 수 있는 브랜치
develop : 다음 출시 버전을 개발하는 브랜치
feature : 기능을 개발하는 브랜치
release : 이번 출시 버전을 준비하는 브랜치
hotfix : 출시 버전에서 발생한 버그를 수정 하는 브랜치

피처 브랜치에서 작업 중
* 만약 커밋이 불필요하게 어려 개로 나뉘어져 있다면 squash를 합니다. (커밋 2개를 합쳐야 한다면)
:커밋이 불필요하게 여러개로 나뉘기 쉽기 때문
* 작업 브랜치를 upstream/feature-user에 rebase합니다.
:같은 피처를 개발한다면 엉키기 쉽다. 커밋을 순차적으로 만들기 위해서 작업한 커밋이 feature의 최신 상태에서 시작하도록 rebase를 수행한다.
```